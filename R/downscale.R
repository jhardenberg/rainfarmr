#' Downscale precipitation field `r` using metagaussian spectral field `f`. 
#' An optional weights array can be specified.
#' Precipitation can be conserved globally (`fglob`) or using convolution (`fsmooth`).
#' @param r The input matrix.
#' @param f A field generated by the `initmetagauss()` function.
#' @param weights Climatological weights generated with the `rfweights()` function.
#' @param fglob Logical to conserve global average over domain.
#' @param fsmooth Logical to use smoothing instead of gridpoint conservation.
#' @return The downscaled field.
#' @import stats
downscale <- function(r, f, weights=1., fglob=FALSE, fsmooth=FALSE) {
  nas <- dim(r)[1]
  ns <- dim(f)[1]
  r[r < 0] <- 0.
  rg <- gaussianize(r)
  g <- metagauss(f)

  pstg <- fft2d(g) * (ns * ns) ^ 2
  pstrg <- fft2d(rg) * (nas * nas) ^ 2
  c <- pstrg[nas / 2] / pstg[nas / 2]
  g <- g * sqrt(c)

  gm <- mergespec(rg, g, nas / 2)
  st <- sd(gm)
  if (st == 0) {
    st <- 1.i
  }
  gm <- gm / st
  fm <- exp(gm)
  fm <- fm * weights
  fm[ !is.finite(r) ] <- NA

  if (fglob) {
    imask <- !is.na(fm)
    ri <- interpola(r, ns)
    fm <- fm * mean(ri[imask]) / mean(fm[imask])
  } else if (fsmooth) {
    imask <- is.na(fm)
    fmi <- interpola(agg(fm, nas), ns);
    fmi[imask] <- NA
    fma <- smoothconv(fmi, nas)
    ri <- interpola(r, ns)
    ri[imask] <- NA
    raa <- smoothconv(ri, nas);
    fm <- raa / fma * fm
  } else {
    raa <- agg(r, nas)
    fma <- agg(fm, nas)
    ca <- raa / fma
    cai <- interpola(ca, ns)
    fm <- cai * fm
  }
  return(fm)
}

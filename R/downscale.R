#' Downscale precipitation field `r` using metagaussian spectral field `f`. 
#' An optional weights array can be specified.
#' Precipitation can be conserved globally (`fglob`) or using convolution (`fsmooth`).
#' @param r The input matrix.
#' @param f A field generated by the `initmetagauss()` function.
#' @param weights Climatological weights generated with the `rfweights()` function.
#' @param fglob Logical to conserve global average over domain.
#' @param fsmooth Logical to use smoothing instead of gridpoint conservation.
#' @return The downscaled field.
#' @import stats
#' @examples
#' # Make some sample synthetic rainfall data
#' r <- exp(rnorm(4 * 4))
#' dim(r) <- c(4, 4)
#' r
#' #           [,1]      [,2]      [,3]      [,4]
#' # [1,] 1.8459816 1.8536550 2.1600665 1.3102116
#' # [2,] 1.3851011 1.4647348 0.2708219 0.4571810
#' # [3,] 0.2492451 0.8227134 0.4790567 1.9320403
#' # [4,] 0.5985922 3.3065678 2.1282795 0.6849944
#' # Create help field `f` with logarithmic slope 1.7 with `dim(f) = c(8 * 4 ,8 * 4)`
#' f <- initmetagauss(1.7, 8 * 4)
#' rd <- downscale(r, f, fsmooth=FALSE) 
#' # Verify that downscaled data maintained original box averages
#' agg(rd, 4) 
#' #           [,1]      [,2]      [,3]      [,4]
#' # [1,] 1.8459816 1.8536550 2.1600665 1.3102116
#' # [2,] 1.3851011 1.4647348 0.2708219 0.4571810
#' # [3,] 0.2492451 0.8227134 0.4790567 1.9320403
#' # [4,] 0.5985922 3.3065678 2.1282795 0.6849944
downscale <- function(r, f, weights = 1., fglob = FALSE, fsmooth = TRUE) {
  nas <- dim(r)[1]
  ns <- dim(f)[1]
  r[r < 0] <- 0.
  rg <- gaussianize(r)
  g <- metagauss(f)

  pstg <- fft2d(g) * (ns * ns) ^ 2
  pstrg <- fft2d(rg) * (nas * nas) ^ 2
  c <- pstrg[nas / 2] / pstg[nas / 2]
  g <- g * sqrt(c)

  gm <- mergespec(rg, g, nas / 2)
  st <- sd(gm)
  if (st == 0) {
    st <- 1.i
  }
  gm <- gm / st
  fm <- exp(gm)
  fm <- fm * weights
  fm[ !is.finite(r) ] <- NA

  if (fglob) {
    imask <- !is.na(fm)
    ri <- interpola(r, ns)
    fm <- fm * mean(ri[imask]) / mean(fm[imask])
  } else if (fsmooth) {
    imask <- is.na(fm)
    fmi <- interpola(agg(fm, nas), ns);
    fmi[imask] <- NA
    fma <- smoothconv(fmi, nas)
    ri <- interpola(r, ns)
    ri[imask] <- NA
    raa <- smoothconv(ri, nas);
    fm <- raa / fma * fm
  } else {
    raa <- agg(r, nas)
    fma <- agg(fm, nas)
    ca <- raa / fma
    cai <- interpola(ca, ns)
    fm <- cai * fm
  }
  return(fm)
}
